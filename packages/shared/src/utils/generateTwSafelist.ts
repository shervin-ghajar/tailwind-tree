/* eslint-disable no-console */
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

import { extractClassesFromNode } from './extractClassesFromNode';
import { parseProgram } from './parser';
import { traverse } from './traverse';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Collect all source files recursively
const getAllSourceFiles = (dir: string): string[] => {
  let results: string[] = [];

  const excludeFiles = ['node_modules', 'dist', '.git'];

  const entries = fs.readdirSync(dir);
  entries.forEach((file) => {
    if (excludeFiles.includes(file)) return;

    const fullPath = path.join(dir, file);
    const stat = fs.statSync(fullPath);

    if (stat.isDirectory()) {
      results = results.concat(getAllSourceFiles(fullPath));
    } else if (/\.(ts|tsx|js|jsx)$/.test(file)) {
      results.push(fullPath);
    }
  });

  return results;
};

// Extract twTree classes from all files
export const collectUsedClasses = (sourceFiles: string[]): Set<string> => {
  const usedClasses = new Set<string>();
  sourceFiles.forEach((filePath) => {
    let content: string;
    try {
      content = fs.readFileSync(filePath, 'utf8');
    } catch {
      console.warn(`⚠️  Failed to read file: ${filePath}`);
      return;
    }
    if (!/\btwTree\s*\(/.test(content)) return;

    const ast = parseProgram(content, filePath);

    // Step 1: Find local import name of twTree
    let twTreeLocalName = 'twTree';
    traverse(ast.program, (node) => {
      if (
        node.type === 'ImportSpecifier' &&
        node.imported?.type === 'Identifier' &&
        node.imported.name === 'twTree'
      ) {
        twTreeLocalName = node.local.name;
      }
    });

    // Step 2: Traverse AST to find all twTree calls
    traverse(ast.program, (node) => {
      if (
        node.type === 'CallExpression' &&
        node.callee?.type === 'Identifier' &&
        node.callee.name === twTreeLocalName
      ) {
        const arg = node.arguments[0];
        const classes = extractClassesFromNode(arg);
        classes.forEach((cls) => cls && usedClasses.add(cls.trim()));
      }
    });
  });

  return usedClasses;
};

// Write the safelist as a valid JS module
export const writeSafelistFile = (classes: string[], safelistPath?: string) => {
  const filePath = safelistPath ?? path.resolve(__dirname, 'safelist.css');

  // Flatten classes: split each space-separated string into individual classes
  const flattenedClasses = classes
    .flatMap((c) => c.split(/\s+/))
    .filter((cls) => cls && cls.includes(':')); // remove empty strings & keep variant classes

  const uniqueClasses = Array.from(new Set(flattenedClasses));

  const contents =
    '/* Auto-generated by tailwind-tree */\n' +
    '/* Do not manually edit this file. */\n\n' +
    uniqueClasses.map((cls) => `@source inline("${cls}");`).join('\n') +
    '\n';

  fs.writeFileSync(filePath, contents, 'utf8');
};

// Main generation function
export const generateTwSafelist = async (filePaths?: string[], safelistPath?: string) => {
  try {
    const files = filePaths ?? getAllSourceFiles(process.cwd());
    const classes = await collectUsedClasses(files);
    writeSafelistFile([...classes], safelistPath);
  } catch (error) {
    console.error('❌ Error generating tw-safelist:', error);
    process.exit(1);
  }
};
